// msfem_diffusion_intrusive.edp
//
// A FreeFEM++ script that shows the usual, intrusive MsFEM approach on a simple diffusion problem
//
// Note that this implementation is possible mainly due to the following in-depth functionality of FreeFEM++:
// - VK(k,i) gives the global degree of freedom of the ith local DOF in the kth triangle of the mesh

string nameMethod = "MsFEM_LIN";
real plots = 0;

///////////////////////////////////////////////////////////////////////
// Declaring and reading external parameters                         //
///////////////////////////////////////////////////////////////////////

// Parameters defining the domain
real L, Lx, Ly;
// Parameters defining the fine mesh
int Ndiscr, Nx, Ny;
// Parameters defining the coarse mesh
int n, nx, ny;
// Parameters defining the PDE
real eps, alpha, cont;
//cont: contrast of the multiscale coefficient
int logalpha;

real tic = clock();

ofstream ffLog("log_msfem.txt", append);

// Reading parameters from external file "parameters.txt"
{
	ifstream f("parameters.txt");
	string read;
	f >> read >> L;        Lx=L; Ly=L;
	f >> read >> Ndiscr;   Nx=Ndiscr; Ny=Ndiscr;
	f >> read >> n;		   nx=n; ny=n;
	f >> read >> eps;
}

string parametersMsFEM = "_N_" + Ndiscr + "_n_" + nx + "_eps_" + eps; 
string parametersREF = "_N_" + Ndiscr + "_eps_" + eps; 

macro printmessage(message) {

    cout << message << endl;
    ffLog << message << endl;
}
//EOM

// Write starting message for the method
printmessage("////////////////////////////////////////////////////////////////")
if (nameMethod == "REF") {
  printmessage("// Calcul de la solution de reference avec les parametres " + parametersREF);
} else {
  printmessage("// Debut de la methode " + nameMethod + " avec les parametres " + parametersMsFEM);
}

Lx=L; Ly=L;
logalpha= 0;
cont= 11;
alpha=2.^logalpha;


real Hx=Lx/nx, Hy=Ly/ny;
mesh Th=square(Nx,Ny,[Lx*x,Ly*y]); //fine mesh
fespace Vh(Th,P1); //fine global FE space
mesh TH=square(nx,ny,[Lx*x,Ly*y]); //coarse mesh
fespace VH(TH,P1); //coarse global FE space 
int Ntri = TH.nt;


///////////////////////////////////////////////////////////////////////
// Define the PDE                                                    //
///////////////////////////////////////////////////////////////////////

// Diffusion coefficient
//func nu=alpha*(1+cont*cos(pi/eps*x)^2*sin(pi/eps*y)^2);
func nu=(6+5*cos(2*pi/eps*x)*sin(2*pi/eps*y));
macro a(dif,u,v) (dif*dx(u)*dx(v) + dif*dy(u)*dy(v))//EOM
// Plot diffusion coefficient
Vh aplot=nu;
if (plots) plot(aplot, value=1, cmm="Diffusion coefficient", wait=1);
// Right-hand side
func fRHS = sin(x)*sin(y);
string rhsDescription = "-- Tests for RHS f = sin(x)*sin(y) --";
// func fRHS = 1;
// string rhsDescription = "-- Tests for RHS f = 1 --";


///////////////////////////////////////////////////////////////////////
// Define internal data structures                                   //
///////////////////////////////////////////////////////////////////////

int nnz=0, nnzmax=9*Ntri;
int[int] Imat(nnzmax); //
int[int] Jmat(nnzmax);
real[int] Mmat(nnzmax); //matrix contributions A[Imat[k],Jmat[k]] = Mmat[k], summing all contributions 
real[int] rhs(TH.nv); rhs=0;
fespace VH0(TH,P0);
VH0 vk=0; // dummy function to truncate the mesh
vk[][0]=1; // vk[] = array of coefficients of vk in the FE basis
mesh Kstore=trunc(Th, vk>0.5, split=1);
vk[][0]=0;
fespace Vstore(Kstore,P1);
Vstore[int] phiEps(3*Ntri); //basis function matrix triangle by triangle
for (int i=0; i<phiEps.n; i++ ) phiEps[i]=0;
macro storeIndex(tri,vertex) (3*tri+vertex)//EOM

real toc = clock();

printmessage("Temps d'initialisation du maillage, et de l'espace de discretisation : " << toc - tic << " secondes ");

///////////////////////////////////////////////////////////////////////
// Offline stage                                                     //
// - Computation of multiscale basis functions                       //
// - Computation of stiffness matrix                                 //
//(- The discrete right-hand side is also computed here)             //
///////////////////////////////////////////////////////////////////////

printmessage("Construction des fonctions de forme ");
tic = clock();

for (int k=0; k<Ntri; k++) {
	vk[][k]=1;
	mesh Kh=trunc(Th, vk>1e-10, split=1); //mesh for the fine-scale resolution of MsFEM functions   
	fespace VK(Kh,P1);
	VK[int] phi(3); //storage of local basis function contributions in the offline loop

	// Resolution of local problems
	varf defMS(uh,vh) = int2d(Kh)(a(nu,uh,vh)) + int1d(Kh)(tgv*uh*vh);
	matrix Aloc=defMS(VK,VK);
	set(Aloc, solver=UMFPACK);
	VH bc=0; //will hold the boundary condition for local problems
	for (int i=0; i<3; i++) {
		int storei = storeIndex(k,i);
		if (i<2) {
			int dofi = VH(k,i); // the index in VH associated to vertex i of triangle k
			bc[][dofi] = 1;
			varf rhsloc(unused,vh) = int1d(Kh)(tgv*bc*vh);
			VK Bloc; Bloc[] = rhsloc(0,VK);
			phi[i][] = Aloc^-1*Bloc[];
			bc[][dofi]=0;
			// contr[s]=i; // seems superfluous ???
			// s++; // seems superfluous ???
		} else {
			VK phiphi = 1;
			for (int j=0; j<2; j++) {
				phiphi[] = phiphi[] - phi[j][];
			}
			phi[i][] = phiphi[];
		}
		phiEps[storei][] = phi[i][]; // save basis functions for multiscale reconstruction below
	}
	// Computation of matrix elements (and of discrete RHS)
	for (int j=0; j<3; j++)
	{ //loop over all corners for matrix contributions on K
		// int jj = contr[j]; // seems superfluous ???
		int dofj = VH(k,j);
		rhs[dofj] += int2d(Kh)(fRHS*phi[j]);
		for (int i=0; i<3; i++) {
			// int ii = contr[i]; // seems superfluous ???
			// Find global DOF index for trial functions j and test function i,
			// compute matrix contributions,
			// save these in Imat[nnz], Jmat[nnz] and Mmat[nnz]
			Imat[nnz] = VH(k,i);
			Jmat[nnz] = dofj;
			Mmat[nnz] = int2d(Kh)(a(nu, phi[i], phi[j]));
			nnz++;
		}
	}
	vk[][k]=0;
}

toc = clock();

printmessage("Temps de construction des fonctions de forme : " << toc - tic << " secondes ");


///////////////////////////////////////////////////////////////////////
// Online stage                                                      //
///////////////////////////////////////////////////////////////////////
tic = clock();

// Define global matrix and add boundary conditions to the system by penalization
matrix Amsfem = [Imat(0:nnz-1), Jmat(0:nnz-1), Mmat(0:nnz-1)];
varf boundarycondition(u,v) = int1d(TH)(tgv*u*v);
matrix Abc = boundarycondition(VH,VH);
matrix Aglob = Amsfem+Abc;
set(Aglob, solver=UMFPACK);

// Resolution of the global problem on the coarse mesh
real[int] uH(VH.ndof);
uH = Aglob^-1 * rhs;
VH uP1=0; //extension of the P1 solution by 0 from the interior domain to the entire domain
uP1[] = uH;
if (plots) plot(uP1, fill=1, value=1, wait=1, cmm="MsFEM solution in P1 basis");

toc = clock();

printmessage("Temps de resolution online du probleme MsFEM : " << toc - tic << " secondes ");
///////////////////////////////////////////////////////////////////////
// Reconstruction of the MsFEM solution on the fine scale            //
///////////////////////////////////////////////////////////////////////
printmessage("Reconstruction of the MsFEM solution on the fine scale");
tic = clock();

Vh uh=0; //multiscale solution
for (int k=0; k<Ntri; k++)
{// Loop over all elements to reuse the multiscale information of the offline stage
	vk[][k]=1;
	int[int] n2oFine;
	mesh Kh=trunc(Th, vk>0.5, split=1, new2old=n2oFine); //mesh for the resolution of MsFEM solution
	fespace VK(Kh,P1);
	int[int] loc2globFine = restrict(VK, Vh, n2oFine);
	
	real[int] uhloc(VK.ndof);
	for (int i=0; i<3; i++) {
		int dofi = VH(k,i);
		int storei = storeIndex(k,i);
		uhloc += uH[dofi]*phiEps[storei][];
	}
	
	uh[](loc2globFine) = uhloc;
	
	vk[][k]=0;
}

if (plots) plot(uh, fill=1, value=1, wait=1, cmm="MsFEM solution (fine mesh)");

toc = clock();
printmessage("Temps de reconstruction of the MsFEM solution on the fine scale : " << toc - tic << " secondes ");


///////////////////////////////////////////////////////////////////////
// Reference solution and error computation                          //
///////////////////////////////////////////////////////////////////////

// Load or compute reference solution
tic = clock();

Vh uref;

cout << "WARNING: No reference solution was found and it is recomputed" << endl;

Vh vh;
solve pb(uref,vh)=int2d(Th)(a(nu,uref,vh)) +int1d(Th)(tgv*uref*vh)
        -int2d(Th)(fRHS*vh);

{
string solname = "./Solutions_reference/sol_diffusive_" + "REF" + parametersREF + ".txt";
ofstream ff(solname);
ff << uref[] << endl;
ff << endl;
}
toc = clock();

printmessage("Temps de calcul de la solution de reference : " << toc - tic << " secondes ");


if (plots) plot(uref,wait=1,value=1,fill=1, cmm="reference solution");

printmessage("Calcul des erreurs et stockage dans un fichier");
tic = clock();

// Compute norms of reference solution
real nL1=0, nL2=0, nH1=0, nMax=0;
nL1=int2d(Th)(abs(uref));
nL2=sqrt(int2d(Th)(uref*uref));
nH1=sqrt(int2d(Th)(uref*uref + dx(uref)*dx(uref) + dy(uref)*dy(uref)));
uref = abs(uref);
nMax=uref[].max;
string printNorms = "norms: " + nL1 + "  " + nL2 + "  " + nH1 + "  " + nMax;

// Compute errors and relative errors
Vh e = uh - uref;
if (plots) plot(e,wait=1,value=1, cmm="error");
real eL1, eL2, eH1, eMax, erL1, erL2, erH1, erMax;
eL1=int2d(Th)(abs(e));
erL1=eL1/nL1;
eL2=sqrt(int2d(Th)(e*e));
erL2=eL2/nL2;
eH1=sqrt(int2d(Th)(dx(e)*dx(e)+dy(e)*dy(e)) + eL2^2 );
erH1=eH1/nH1;
e=abs(e);
eMax=e[].max;
erMax=eMax/nMax;

{// Writing errors to an external file
    string errname = "./Results/errors_diffusion_" + nameMethod + ".txt";
    ofstream ff(errname, append);
    ff  << rhsDescription
        << endl
        << "\t"
        << "n\t" << n << "\t"
        << "N\t" << Ndiscr << "\t"
        << "eps\t" << eps << "\t"
        << endl
        << "\t\tL1\t\tL2\t\tH1\t\tmax\t\tL1rel\t\tL2rel\t\tH1rel\t\tmaxrel\t\t"
        << endl;        
    
    ff  << "\t\t"
        << eL1  <<"\t"<< eL2  <<"\t"<< eH1  <<"\t"<< eMax  <<"\t"
        << erL1 <<"\t"<< erL2 <<"\t"<< erH1 <<"\t"<< erMax
        << endl;
    
	ff<<endl;
}
toc = clock();

printmessage("Temps de calcul des erreurs : " << toc - tic << " secondes ");

printmessage("////////////////////////////////////////////////////////////////");