// react_diff_P1.edp
//
// A FreeFEM++ script that shows the usual, intrusive MsFEM approach on a simple diffusion problem
//
// Note that this implementation is possible mainly due to the following in-depth functionality of FreeFEM++:
// - VK(k,i) gives the global degree of freedom of the ith local DOF in the kth triangle of the mesh

//mpirun -np 1 FreeFem++-mpi -wg main_react_diff_MsFEM_OS_square.edp -v 0

string nameMethod = "MsFEM_OS_carre";

include "init.edp"

///////////////////////////////////////////////////////////////////////
// Offline stage                                                     //
// - Computation of multiscale basis functions                       //
// - Computation of stiffness matrix                                 //
//(- The discrete right-hand side is also computed here)             //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// - Computation of multiscale basis functions                       //
///////////////////////////////////////////////////////////////////////

printmessage("Construction des fonctions de forme ");
tic = clock();


int NumTri = (Ntri/2) + 4 ;

vk[][NumTri]=1;
// Defining the vertices of the ideal oversampling patch (possibly lying partially outside the global domain)
real[int,int] Kx(3,2); //save coordinates of the vertices belonging to K
for(int kk=0; kk<3; kk++) {
    Kx(kk,0) = TH[NumTri][kk].x;
    Kx(kk,1) = TH[NumTri][kk].y;
}
real[int,int] Sx(3,2); //compute coordinates for the ideal oversampling patch by homothety
for(int kk=0; kk<3; kk++) {
    Sx(kk,0) = (osCoef)*(Kx(kk,0) - xb[][NumTri]) + xb[][NumTri];
    Sx(kk,1) = (osCoef)*(Kx(kk,1) - yb[][NumTri]) + yb[][NumTri];
}

// Construction of a patch-container C around S that is (much) smaller than Omega
int NxC = Nx/nx;
int NyC = Ny/ny;

real xCL = (floor(Sx(:,0).min/hx)-1)*hx; //we take a small margin around the vertices of S as computed above
xCL = max(0.,xCL); //ensure that the patch-container is a subset of the global domain
real xCR = (ceil(Sx(:,0).max/hx)+1)*hx;
xCR=min(Lx, xCR);
real yCL = (floor(Sx(:,1).min/hy)-1)*hy;
yCL = max(0., yCL);
real yCR = (ceil(Sx(:,1).max/hy)+1)*hy;
yCR = min(Ly, yCR);

real dxC = xCR - xCL;
int dxCn = lrint(dxC/hx); //integer closest to dxC/hx -- ensures that the mesh C defined below is compatible with Th
real dyC = yCR - yCL;
int dyCn = lrint(dyC/hy);

mesh C=square(dxCn, dyCn, [xCL + dxC*x, yCL + dyC*y]);
fespace VCperiodic(C, P1, periodic=[[2, y], [4, y], [1, x], [3, x]]);



// Construction of the actual coarse mesh element K inside of the patch
int[int] S2K;
mesh K=trunc(C,vk>0.5,split=1,label=1,new2old=S2K); 
fespace VK(K,P1);
int[int] RS2Kperiodic = restrict(VK,VCperiodic,S2K); //array for the restriction of a function on S to K


if (plots) plot(C, vk, fill=1, cmm="Mesh element and oversampling patch", wait=1);
if (plots) plot(C, K, cmm="Coarse mesh element", wait=1);


// Problem
varf oploc (u, v)
    = int2d(C)(
        sigmaeps*u*v)
    + int2d(C)(eps^2*a(Aeps,u,v))
    ;

varf bloc (u, v) = int2d(C)(u*v); //no boundary condition

// Psi_eps
//////////////////////////////////////////////////////////////////////////////////////////////////
include "Psi_triche.edp"
Vh Psieps;

Psieps = VecteurproprePsi(fmod(x/eps,1), fmod(y/eps,1)) ;

VCperiodic PsiS=1;

PsiS = Psieps*PsiS;
// Square CL periodic
//////////////////////////////////////////////////////////////////////////////////////////////////
matrix<real> AlocS = oploc(VCperiodic, VCperiodic, factorize=1); 
matrix<real> BlocS = bloc(VCperiodic, VCperiodic, solver=CG, eps=1e-20);

Mat Aloctemp = AlocS;
Mat Bloctemp = BlocS;

real[int] Listelambdaloc(1); //to store the nev eigenvalue (nev = 1 ici)
VCperiodic[int] ListeVecteurproprelocS(1); //to store the nev eigenvector

int kloc = EPSSolve(Aloctemp, Bloctemp, vectors = ListeVecteurproprelocS, values  = Listelambdaloc, sparams = ssparams); //Résolution du pb aux vp
kloc=min(kloc,1);

VCperiodic VecteurproprelocS;
VecteurproprelocS[] = ListeVecteurproprelocS[0][];

if (VecteurproprelocS(xb[][NumTri] , yb[][NumTri])<0)  //Evaluation au point milieu
{
    VecteurproprelocS = -VecteurproprelocS;
}

// Renormalisation
real normeL2loc=sqrt(int2d(C)(VecteurproprelocS*VecteurproprelocS));
VecteurproprelocS[] = VecteurproprelocS[]/(normeL2loc/sqrt(int2d(C)(1)));

if (plots) plot(VecteurproprelocS, value=1, cmm="Local eigenvector Phieps on S", wait=1);

if (plots) plot(PsiS, value=1, cmm="Local eigenvector Psi on S", wait=1);

VCperiodic DiffPhiPsi = VecteurproprelocS - PsiS;
if (plots) plot(DiffPhiPsi, value=1, cmm="Difference between Phieps and Psi", wait=1);

/* VCperiodic deriveeDiffPhiPsi = sqrt(dx(DiffPhiPsi)*dx(DiffPhiPsi) + dy(DiffPhiPsi)*dy(DiffPhiPsi));
if (plots) plot(deriveeDiffPhiPsi, value=1, cmm="Derivative of the difference between Phieps and Psi", wait=1);
 */
VK VecteurproprelocKtmp=0;
VecteurproprelocKtmp[] = VecteurproprelocS[](RS2Kperiodic);
VK PsiSlocKtmp=0;
PsiSlocKtmp[] = PsiS[](RS2Kperiodic);

if (plots) plot(VecteurproprelocKtmp, value=1, cmm="Local eigenvector Phieps periodic on K", wait=1);
if (plots) plot(PsiSlocKtmp, value=1, cmm="Local eigenvector Psi on K", wait=1);

// Square CL dirichlet
//////////////////////////////////////////////////////////////////////////////////////////////////
fespace VCdirichlet(C, P1);
int[int] RS2Kdirichlet = restrict(VK,VCdirichlet,S2K); //array for the restriction of a function on S to K

// Problem
varf oplocdirichlet (u, v)
    = int2d(C)(
        sigmaeps*u*v)
    + int2d(C)(eps^2*a(Aeps,u,v))

    + int1d(C)(tgv*u*v)
    ;

matrix<real> AlocSdirichlet = oplocdirichlet(VCdirichlet, VCdirichlet, factorize=1); 
matrix<real> BlocSdirichlet = bloc(VCdirichlet, VCdirichlet, solver=CG, eps=1e-20);

Mat Aloctempdirichlet = AlocSdirichlet;
Mat Bloctempdirichlet = BlocSdirichlet;

real[int] Listelambdalocdirichlet(1); //to store the nev eigenvalue (nev = 1 ici)
VCdirichlet[int] ListeVecteurproprelocSdirichlet(1); //to store the nev eigenvector

int klocdirichlet = EPSSolve(Aloctempdirichlet, Bloctempdirichlet, vectors = ListeVecteurproprelocSdirichlet, values  = Listelambdalocdirichlet, sparams = ssparams); //Résolution du pb aux vp
klocdirichlet=min(kloc,1);

VCdirichlet VecteurproprelocSdirichlet;
VecteurproprelocSdirichlet[] = ListeVecteurproprelocSdirichlet[0][];

if (VecteurproprelocSdirichlet(xb[][NumTri] , yb[][NumTri])<0)  //Evaluation au point milieu
{
    VecteurproprelocSdirichlet = -VecteurproprelocSdirichlet;
}

// Renormalisation
real normeL2locdirichlet=sqrt(int2d(C)(VecteurproprelocSdirichlet*VecteurproprelocSdirichlet));
VecteurproprelocSdirichlet[] = VecteurproprelocSdirichlet[]/(normeL2locdirichlet/sqrt(int2d(C)(1)));

VK VecteurproprelocKdirichlet=0;
VecteurproprelocKdirichlet[] = VecteurproprelocSdirichlet[](RS2Kdirichlet);

VCdirichlet PsiSdirichlet=1;

PsiSdirichlet = Psieps*PsiSdirichlet;

VK PsiSlocKdirichlet=0;
PsiSlocKdirichlet[] = PsiSdirichlet[](RS2Kdirichlet);


if (plots) plot(VecteurproprelocSdirichlet, value=1, cmm="Local eigenvector Phieps on S", wait=1);

if (plots) plot(PsiSdirichlet, value=1, cmm="Local eigenvector Psi on S", wait=1);

VCdirichlet DiffPhiPsidirichlet = VecteurproprelocSdirichlet - PsiSdirichlet;
if (plots) plot(DiffPhiPsidirichlet, value=1, cmm="Difference between Phieps dirichlet and Psi", wait=1);

/* VCperiodic deriveeDiffPhiPsi = sqrt(dx(DiffPhiPsi)*dx(DiffPhiPsi) + dy(DiffPhiPsi)*dy(DiffPhiPsi));
if (plots) plot(deriveeDiffPhiPsi, value=1, cmm="Derivative of the difference between Phieps and Psi", wait=1);
 */

if (plots) plot(VecteurproprelocKdirichlet, value=1, cmm="Local eigenvector Phieps periodic on K", wait=1);
if (plots) plot(PsiSlocKdirichlet, value=1, cmm="Local eigenvector Psi on K", wait=1);




// Calcul des erreurs et stockage dans un ficher
//////////////////////////////////////////////////////////////////////////////////////////////////
VK DiffPhiPsiK = VecteurproprelocKtmp - PsiSlocKtmp;
real eH1=int2d(K)(dx(DiffPhiPsiK)*dx(DiffPhiPsiK)+dy(DiffPhiPsiK)*dy(DiffPhiPsiK) + DiffPhiPsiK*DiffPhiPsiK);
real nH1=int2d(K)(dx(PsiSlocKtmp)*dx(PsiSlocKtmp)+dy(PsiSlocKtmp)*dy(PsiSlocKtmp) + PsiSlocKtmp*PsiSlocKtmp);
real erH1 = sqrt(eH1/nH1);

printmessage("Erreur relative sur K : " << erH1 );


vk[][NumTri]=0;

// Writing errors to an external file
string errname = "erreur_patch_carre" + ".txt";
ofstream ff(errname, append);
ff  << "\t"
    << "eps\t" << eps << "\t" << "ErH1\t" << erH1 << "\t"
    << endl;        

ff<<endl;

printmessage("Erreur relative sur K : " << erH1 );